"""slskd MCP Server (auto-generated).

Generated for slskd API v0.
Total tools: ~93

DO NOT EDIT THIS FILE. All changes must be made in the generator or templates.
"""

from __future__ import annotations

import base64
import json
import os
from typing import Any

import httpx
from fastmcp import FastMCP

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------

SLSKD_URL = os.environ.get("SLSKD_URL", "http://localhost:5030")
SLSKD_API_KEY = os.environ.get("SLSKD_API_KEY", "")
SLSKD_MODULES = os.environ.get("SLSKD_MODULES", "")
SLSKD_READ_ONLY = os.environ.get("SLSKD_READ_ONLY", "false").lower() == "true"

# Parse enabled modules
_enabled_modules: set[str] | None = None
if SLSKD_MODULES:
    _enabled_modules = {m.strip() for m in SLSKD_MODULES.split(",") if m.strip()}

ALL_MODULES = ['application', 'conversations', 'events', 'files', 'logs', 'options', 'relay', 'rooms', 'searches', 'server', 'session', 'shares', 'telemetry', 'transfers', 'users']


def _module_enabled(module: str | None) -> bool:
    """Check if a module is enabled."""
    if module is None:
        return True
    if _enabled_modules is not None:
        return module in _enabled_modules
    return True


# ---------------------------------------------------------------------------
# HTTP Client
# ---------------------------------------------------------------------------

class SlskdClient:
    """Async HTTP client for the slskd API."""

    def __init__(self) -> None:
        self._client: httpx.AsyncClient | None = None

    async def _get_client(self) -> httpx.AsyncClient:
        if self._client is None or self._client.is_closed:
            self._client = httpx.AsyncClient(
                base_url=SLSKD_URL,
                headers={"X-Api-Key": SLSKD_API_KEY},
                timeout=30.0,
                verify=False,
            )
        return self._client

    async def request(
        self,
        method: str,
        path: str,
        params: dict[str, Any] | None = None,
        json_body: dict[str, Any] | list[Any] | None = None,
    ) -> dict[str, Any] | list[Any]:
        client = await self._get_client()
        response = await client.request(
            method,
            path,
            params=params,
            json=json_body,
        )
        response.raise_for_status()
        if response.status_code == 204 or not response.content:
            return {"status": "success", "message": "No content"}
        return response.json()


_client = SlskdClient()

# ---------------------------------------------------------------------------
# Base64 encoding helper
# ---------------------------------------------------------------------------

def _b64encode(value: str) -> str:
    """Base64-encode a string for use in slskd path parameters."""
    return base64.b64encode(value.encode("utf-8")).decode("ascii")


# ---------------------------------------------------------------------------
# Response helpers
# ---------------------------------------------------------------------------

def _compact_value(v: Any) -> Any:
    """Compact a single value for list-response auto-compaction."""
    if isinstance(v, dict) and len(v) > 4:
        if "id" in v:
            return {"id": v["id"]}
        return {"_keys": len(v)}
    if isinstance(v, list) and v and isinstance(v[0], dict):
        return f"[{len(v)} items]"
    return v


def _compact_object(row: dict[str, Any]) -> dict[str, Any]:
    """Auto-compact nested objects in a single row."""
    return {k: _compact_value(v) for k, v in row.items()}


def _filter_response(
    data: list[dict[str, Any]],
    fields: str = "",
    filter_expr: str = "",
) -> dict[str, Any]:
    """Filter list response with field selection, row filtering, and auto-compaction."""
    result = data
    if filter_expr:
        for pair in filter_expr.split(","):
            pair = pair.strip()
            if "=" not in pair:
                continue
            k, v = pair.split("=", 1)
            result = [
                row for row in result
                if str(row.get(k.strip())) == v.strip()
            ]
    if fields:
        field_set = {f.strip() for f in fields.split(",")} | {"id"}
        result = [{k: v for k, v in row.items() if k in field_set} for row in result]
    else:
        result = [_compact_object(row) for row in result]
    return {"summary": f"Found {len(result)} items", "count": len(result), "data": result}


# ---------------------------------------------------------------------------
# FastMCP Server
# ---------------------------------------------------------------------------

mcp = FastMCP("slskd-mcp")

# ---------------------------------------------------------------------------
# Always-registered tools
# ---------------------------------------------------------------------------

@mcp.tool()
async def slskd_get_overview() -> dict[str, Any]:
    """Get a system overview: server state, transfer counts, search activity.

    Returns a unified summary in a single call.
    """
    import asyncio
    server, downloads, uploads, searches = await asyncio.gather(
        _client.request("GET", "/api/v0/server"),
        _client.request("GET", "/api/v0/transfers/downloads"),
        _client.request("GET", "/api/v0/transfers/uploads"),
        _client.request("GET", "/api/v0/searches"),
    )
    return {
        "server": server,
        "downloadCount": len(downloads) if isinstance(downloads, list) else 0,
        "uploadCount": len(uploads) if isinstance(uploads, list) else 0,
        "searchCount": len(searches) if isinstance(searches, list) else 0,
    }


@mcp.tool()
async def slskd_search_tools(keyword: str) -> dict[str, Any]:
    """Search for tools by keyword (e.g. 'search', 'download', 'transfer').

    Use this tool first to find the right tool before trying to call it directly.
    """
    keyword_lower = keyword.lower()
    matches = []
    for tool in mcp._tool_manager._tools.values():
        if keyword_lower in tool.name.lower() or keyword_lower in (tool.description or "").lower():
            matches.append({"name": tool.name, "description": (tool.description or "")[:120]})
    return {"summary": f"Found {len(matches)} tools matching '{keyword}'", "matches": matches}


@mcp.tool()
async def slskd_report_issue(
    tool_name: str,
    error_message: str,
    parameters_used: str = "",
    notes: str = "",
) -> str:
    """Generate a structured bug report for unexpected errors.

    Returns a ready-to-paste `gh issue create` command. Makes no HTTP calls.
    If any tool returns an unexpected error, call this to report it.
    """
    body = f"""## Bug Report

**Tool:** `{tool_name}`
**Error:** `{error_message}`
**Parameters:** `{parameters_used}`

### Notes
{notes}

### Environment
- slskd MCP Server
- Generated from OpenAPI spec
"""
    title = f"Bug: {tool_name} â€” {error_message[:60]}"
    cmd = f'gh issue create --repo abl030/slskd-mcp --title "{title}" --body "$(cat <<\'GHEOF\'\n{body}\nGHEOF\n)"'
    return cmd


# ---------------------------------------------------------------------------
# Generated tools
# ---------------------------------------------------------------------------

if _module_enabled("application"):

    @mcp.tool()
    async def slskd_list_application(
    ) -> dict[str, Any] | list[Any] | str:
        """Gets the current state of the application If unexpected errors occur, call slskd_report_issue.

        """
        _path = "/api/v0/application"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_application",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_application",
            }
        return _resp

if _module_enabled("application"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_update_application(
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Restarts the application If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "PUT /api/v0/application", "confirm": "Set confirm=True to execute this PUT request."}
            _path = "/api/v0/application"
            try:
                _resp = await _client.request(
                    "PUT",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_update_application",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_update_application",
                }
            return _resp

if _module_enabled("application"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_delete_application(
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Stops the application If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "DELETE /api/v0/application", "confirm": "Set confirm=True to execute this DELETE request."}
            _path = "/api/v0/application"
            try:
                _resp = await _client.request(
                    "DELETE",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_delete_application",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_delete_application",
                }
            return _resp

if _module_enabled("application"):

    @mcp.tool()
    async def slskd_list_application_dump(
    ) -> dict[str, Any] | list[Any] | str:
        """List application dump If unexpected errors occur, call slskd_report_issue.

        """
        _path = "/api/v0/application/dump"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_application_dump",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_application_dump",
            }
        return _resp

if _module_enabled("application"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_create_application_gc(
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Forces garbage collection If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "POST /api/v0/application/gc", "confirm": "Set confirm=True to execute this POST request."}
            _path = "/api/v0/application/gc"
            try:
                _resp = await _client.request(
                    "POST",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_create_application_gc",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_create_application_gc",
                }
            return _resp

if _module_enabled("application"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_create_application_loopback(
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Create application loopback If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "POST /api/v0/application/loopback", "confirm": "Set confirm=True to execute this POST request."}
            _path = "/api/v0/application/loopback"
            try:
                _resp = await _client.request(
                    "POST",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_create_application_loopback",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_create_application_loopback",
                }
            return _resp

if _module_enabled("application"):

    @mcp.tool()
    async def slskd_list_application_version(
    ) -> dict[str, Any] | list[Any] | str:
        """Gets the current application version If unexpected errors occur, call slskd_report_issue.

        """
        _path = "/api/v0/application/version"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_application_version",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_application_version",
            }
        return _resp

if _module_enabled("application"):

    @mcp.tool()
    async def slskd_list_application_version_latest(
        forceCheck: bool = False,
    ) -> dict[str, Any] | list[Any] | str:
        """Checks for updates If unexpected errors occur, call slskd_report_issue.

        """
        _path = "/api/v0/application/version/latest"
        _params: dict[str, Any] = {}
        if forceCheck is not None:
            _params["forceCheck"] = forceCheck
        try:
            _resp = await _client.request(
                "GET",
                _path,
                params=_params,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_application_version_latest",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_application_version_latest",
            }
        return _resp

if _module_enabled("conversations"):

    @mcp.tool()
    async def slskd_list_conversations(
        fields: str = "",
        filter: str = "",
        includeInactive: bool = False,
        unAcknowledgedOnly: bool = False,
    ) -> dict[str, Any] | list[Any] | str:
        """Gets all active conversations. Returns a list. If unexpected errors occur, call slskd_report_issue.

        fields: Comma-separated field names to include. Omit for auto-compacted results.
        filter: Comma-separated key=value pairs to filter rows.
        """
        _path = "/api/v0/conversations"
        _params: dict[str, Any] = {}
        if includeInactive is not None:
            _params["includeInactive"] = includeInactive
        if unAcknowledgedOnly is not None:
            _params["unAcknowledgedOnly"] = unAcknowledgedOnly
        try:
            _resp = await _client.request(
                "GET",
                _path,
                params=_params,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_conversations",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_conversations",
            }
        if isinstance(_resp, list):
            return _filter_response(_resp, fields=fields, filter_expr=filter)
        return _resp

if _module_enabled("conversations"):

    @mcp.tool()
    async def slskd_get_conversation(
        username: str,
        includeMessages: bool = True,
    ) -> dict[str, Any] | list[Any] | str:
        """Gets the conversation associated with the specified username If unexpected errors occur, call slskd_report_issue.

        username: The username associated with the desired conversation.
        """
        _path = f"/api/v0/conversations/{username}"
        _params: dict[str, Any] = {}
        if includeMessages is not None:
            _params["includeMessages"] = includeMessages
        try:
            _resp = await _client.request(
                "GET",
                _path,
                params=_params,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_conversation",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_conversation",
            }
        return _resp

if _module_enabled("conversations"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_create_conversations(
            username: str,
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Sends a private message to the specified username If unexpected errors occur, call slskd_report_issue. Note: Read replies with slskd_get_conversations_messages. Acknowledge messages with slskd_update_conversation.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "POST /api/v0/conversations/{username}", "confirm": "Set confirm=True to execute this POST request."}
            _path = f"/api/v0/conversations/{username}"
            try:
                _resp = await _client.request(
                    "POST",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_create_conversations",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_create_conversations",
                }
            return _resp

if _module_enabled("conversations"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_update_conversation(
            username: str,
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Acknowledges all messages from the given username If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "PUT /api/v0/conversations/{username}", "confirm": "Set confirm=True to execute this PUT request."}
            _path = f"/api/v0/conversations/{username}"
            try:
                _resp = await _client.request(
                    "PUT",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_update_conversation",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_update_conversation",
                }
            return _resp

if _module_enabled("conversations"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_delete_conversation(
            username: str,
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Closes the conversation associated with the given username If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "DELETE /api/v0/conversations/{username}", "confirm": "Set confirm=True to execute this DELETE request."}
            _path = f"/api/v0/conversations/{username}"
            try:
                _resp = await _client.request(
                    "DELETE",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_delete_conversation",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_delete_conversation",
                }
            return _resp

if _module_enabled("conversations"):

    @mcp.tool()
    async def slskd_get_conversations_messages(
        username: str,
        fields: str = "",
        filter: str = "",
        unAcknowledgedOnly: bool = False,
    ) -> dict[str, Any] | list[Any] | str:
        """Get conversations messages by ID. Returns a list. If unexpected errors occur, call slskd_report_issue.

        fields: Comma-separated field names to include. Omit for auto-compacted results.
        filter: Comma-separated key=value pairs to filter rows.
        """
        _path = f"/api/v0/conversations/{username}/messages"
        _params: dict[str, Any] = {}
        if unAcknowledgedOnly is not None:
            _params["unAcknowledgedOnly"] = unAcknowledgedOnly
        try:
            _resp = await _client.request(
                "GET",
                _path,
                params=_params,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_conversations_messages",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_conversations_messages",
            }
        if isinstance(_resp, list):
            return _filter_response(_resp, fields=fields, filter_expr=filter)
        return _resp

if _module_enabled("conversations"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_update_conversation_message(
            username: str,
            id: int,
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Acknowledges the given message id for the given username If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "PUT /api/v0/conversations/{username}/{id}", "confirm": "Set confirm=True to execute this PUT request."}
            _path = f"/api/v0/conversations/{username}/{id}"
            try:
                _resp = await _client.request(
                    "PUT",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_update_conversation_message",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_update_conversation_message",
                }
            return _resp

if _module_enabled("events"):

    @mcp.tool()
    async def slskd_list_events(
        fields: str = "",
        filter: str = "",
        offset: int = 0,
        limit: int = 100,
    ) -> dict[str, Any] | list[Any] | str:
        """Retrieves a paginated list of past event records. Returns a list. If unexpected errors occur, call slskd_report_issue. Note: Event types: DownloadFileComplete, DownloadDirectoryComplete, UploadFileComplete, PrivateMessageReceived, RoomMessageReceived.

        offset: The offset (number of records) at which to start the requested page.
        limit: The page size.
        fields: Comma-separated field names to include. Omit for auto-compacted results.
        filter: Comma-separated key=value pairs to filter rows.
        """
        _path = "/api/v0/events"
        _params: dict[str, Any] = {}
        if offset is not None:
            _params["offset"] = offset
        if limit is not None:
            _params["limit"] = limit
        try:
            _resp = await _client.request(
                "GET",
                _path,
                params=_params,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_events",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_events",
            }
        if isinstance(_resp, list):
            return _filter_response(_resp, fields=fields, filter_expr=filter)
        return _resp

if _module_enabled("events"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_create_events(
            type: str,
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Raises a sample event of the specified type If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            type: The type of event to raise.
            """
            if not confirm:
                return {"preview": "POST /api/v0/events/{type}", "confirm": "Set confirm=True to execute this POST request."}
            _path = f"/api/v0/events/{type}"
            try:
                _resp = await _client.request(
                    "POST",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_create_events",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_create_events",
                }
            return _resp

if _module_enabled("files"):

    @mcp.tool()
    async def slskd_list_files_downloads_directories(
        recursive: bool = False,
    ) -> dict[str, Any] | list[Any] | str:
        """Lists the contents of the downloads directory If unexpected errors occur, call slskd_report_issue.

        recursive: An optional value indicating whether to recursively list subdirectories and files.
        """
        _path = "/api/v0/files/downloads/directories"
        _params: dict[str, Any] = {}
        if recursive is not None:
            _params["recursive"] = recursive
        try:
            _resp = await _client.request(
                "GET",
                _path,
                params=_params,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_files_downloads_directories",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_files_downloads_directories",
            }
        return _resp

if _module_enabled("files"):

    @mcp.tool()
    async def slskd_get_files_downloads_directories(
        base64SubdirectoryName: str,
        recursive: bool = False,
    ) -> dict[str, Any] | list[Any] | str:
        """Lists the contents of the specified subdirectory within the downloads directory If unexpected errors occur, call slskd_report_issue.

        base64SubdirectoryName: The relative, base 64 encoded, name of the subdirectory to list.
        recursive: An optional value indicating whether to recursively list subdirectories and files.
        """
        base64SubdirectoryName = _b64encode(base64SubdirectoryName)
        _path = f"/api/v0/files/downloads/directories/{base64SubdirectoryName}"
        _params: dict[str, Any] = {}
        if recursive is not None:
            _params["recursive"] = recursive
        try:
            _resp = await _client.request(
                "GET",
                _path,
                params=_params,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_files_downloads_directories",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_files_downloads_directories",
            }
        return _resp

if _module_enabled("files"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_delete_files_downloads_directories(
            base64SubdirectoryName: str,
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Deletes the specified subdirectory within the downloads directory If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            base64SubdirectoryName: The relative, base 64 encoded, name of the subdirectory to delete.
            """
            if not confirm:
                return {"preview": "DELETE /api/v0/files/downloads/directories/{base64SubdirectoryName}", "confirm": "Set confirm=True to execute this DELETE request."}
            base64SubdirectoryName = _b64encode(base64SubdirectoryName)
            _path = f"/api/v0/files/downloads/directories/{base64SubdirectoryName}"
            try:
                _resp = await _client.request(
                    "DELETE",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_delete_files_downloads_directories",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_delete_files_downloads_directories",
                }
            return _resp

if _module_enabled("files"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_delete_files_downloads_files(
            base64FileName: str,
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Deletes the specified file within the downloads directory If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            base64FileName: The relative, base 64 encoded, name of the file to delete.
            """
            if not confirm:
                return {"preview": "DELETE /api/v0/files/downloads/files/{base64FileName}", "confirm": "Set confirm=True to execute this DELETE request."}
            base64FileName = _b64encode(base64FileName)
            _path = f"/api/v0/files/downloads/files/{base64FileName}"
            try:
                _resp = await _client.request(
                    "DELETE",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_delete_files_downloads_files",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_delete_files_downloads_files",
                }
            return _resp

if _module_enabled("files"):

    @mcp.tool()
    async def slskd_list_files_incomplete_directories(
        recursive: bool = False,
    ) -> dict[str, Any] | list[Any] | str:
        """Lists the contents of the downloads directory If unexpected errors occur, call slskd_report_issue.

        recursive: An optional value indicating whether to recursively list subdirectories and files.
        """
        _path = "/api/v0/files/incomplete/directories"
        _params: dict[str, Any] = {}
        if recursive is not None:
            _params["recursive"] = recursive
        try:
            _resp = await _client.request(
                "GET",
                _path,
                params=_params,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_files_incomplete_directories",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_files_incomplete_directories",
            }
        return _resp

if _module_enabled("files"):

    @mcp.tool()
    async def slskd_get_files_incomplete_directories(
        base64SubdirectoryName: str,
        recursive: bool = False,
    ) -> dict[str, Any] | list[Any] | str:
        """Lists the contents of the specified subdirectory within the incomplete directory If unexpected errors occur, call slskd_report_issue.

        base64SubdirectoryName: The relative, base 64 encoded, name of the subdirectory to list.
        recursive: An optional value indicating whether to recursively list subdirectories and files.
        """
        base64SubdirectoryName = _b64encode(base64SubdirectoryName)
        _path = f"/api/v0/files/incomplete/directories/{base64SubdirectoryName}"
        _params: dict[str, Any] = {}
        if recursive is not None:
            _params["recursive"] = recursive
        try:
            _resp = await _client.request(
                "GET",
                _path,
                params=_params,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_files_incomplete_directories",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_files_incomplete_directories",
            }
        return _resp

if _module_enabled("files"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_delete_files_incomplete_directories(
            base64SubdirectoryName: str,
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Deletes the specified subdirectory within the downloads directory If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            base64SubdirectoryName: The relative, base 64 encoded, name of the subdirectory to delete.
            """
            if not confirm:
                return {"preview": "DELETE /api/v0/files/incomplete/directories/{base64SubdirectoryName}", "confirm": "Set confirm=True to execute this DELETE request."}
            base64SubdirectoryName = _b64encode(base64SubdirectoryName)
            _path = f"/api/v0/files/incomplete/directories/{base64SubdirectoryName}"
            try:
                _resp = await _client.request(
                    "DELETE",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_delete_files_incomplete_directories",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_delete_files_incomplete_directories",
                }
            return _resp

if _module_enabled("files"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_delete_files_incomplete_files(
            base64FileName: str,
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Deletes the specified file within the downloads directory If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            base64FileName: The relative, base 64 encoded, name of the file to delete.
            """
            if not confirm:
                return {"preview": "DELETE /api/v0/files/incomplete/files/{base64FileName}", "confirm": "Set confirm=True to execute this DELETE request."}
            base64FileName = _b64encode(base64FileName)
            _path = f"/api/v0/files/incomplete/files/{base64FileName}"
            try:
                _resp = await _client.request(
                    "DELETE",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_delete_files_incomplete_files",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_delete_files_incomplete_files",
                }
            return _resp

if _module_enabled("logs"):

    @mcp.tool()
    async def slskd_list_logs(
        fields: str = "",
        filter: str = "",
    ) -> dict[str, Any] | list[Any] | str:
        """Gets the last few application logs. Returns a list. If unexpected errors occur, call slskd_report_issue.

        fields: Comma-separated field names to include. Omit for auto-compacted results.
        filter: Comma-separated key=value pairs to filter rows.
        """
        _path = "/api/v0/logs"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_logs",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_logs",
            }
        if isinstance(_resp, list):
            return _filter_response(_resp, fields=fields, filter_expr=filter)
        return _resp

if _module_enabled("options"):

    @mcp.tool()
    async def slskd_list_options(
    ) -> dict[str, Any] | list[Any] | str:
        """Gets the current application options If unexpected errors occur, call slskd_report_issue.

        """
        _path = "/api/v0/options"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_options",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_options",
            }
        return _resp

if _module_enabled("options"):

    @mcp.tool()
    async def slskd_list_options_debug(
    ) -> dict[str, Any] | list[Any] | str:
        """Gets the debug view of the current application options If unexpected errors occur, call slskd_report_issue.

        """
        _path = "/api/v0/options/debug"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_options_debug",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_options_debug",
            }
        return _resp

if _module_enabled("options"):

    @mcp.tool()
    async def slskd_list_options_startup(
    ) -> dict[str, Any] | list[Any] | str:
        """Gets the application options provided at startup If unexpected errors occur, call slskd_report_issue.

        """
        _path = "/api/v0/options/startup"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_options_startup",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_options_startup",
            }
        return _resp

if _module_enabled("options"):

    @mcp.tool()
    async def slskd_list_options_yaml(
    ) -> dict[str, Any] | list[Any] | str:
        """List options yaml If unexpected errors occur, call slskd_report_issue.

        """
        _path = "/api/v0/options/yaml"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_options_yaml",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_options_yaml",
            }
        return _resp

if _module_enabled("options"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_create_options_yaml(
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Create options yaml If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "POST /api/v0/options/yaml", "confirm": "Set confirm=True to execute this POST request."}
            _path = "/api/v0/options/yaml"
            try:
                _resp = await _client.request(
                    "POST",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_create_options_yaml",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_create_options_yaml",
                }
            return _resp

if _module_enabled("options"):

    @mcp.tool()
    async def slskd_list_options_yaml_location(
    ) -> dict[str, Any] | list[Any] | str:
        """List options yaml location If unexpected errors occur, call slskd_report_issue.

        """
        _path = "/api/v0/options/yaml/location"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_options_yaml_location",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_options_yaml_location",
            }
        return _resp

if _module_enabled("options"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_create_options_yaml_validate(
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Create options yaml validate If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "POST /api/v0/options/yaml/validate", "confirm": "Set confirm=True to execute this POST request."}
            _path = "/api/v0/options/yaml/validate"
            try:
                _resp = await _client.request(
                    "POST",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_create_options_yaml_validate",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_create_options_yaml_validate",
                }
            return _resp

if _module_enabled("relay"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_update_relay_agent(
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Connects to the configured controller If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "PUT /api/v0/relay/agent", "confirm": "Set confirm=True to execute this PUT request."}
            _path = "/api/v0/relay/agent"
            try:
                _resp = await _client.request(
                    "PUT",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_update_relay_agent",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_update_relay_agent",
                }
            return _resp

if _module_enabled("relay"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_delete_relay_agent(
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Disconnects from the connected controller If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "DELETE /api/v0/relay/agent", "confirm": "Set confirm=True to execute this DELETE request."}
            _path = "/api/v0/relay/agent"
            try:
                _resp = await _client.request(
                    "DELETE",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_delete_relay_agent",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_delete_relay_agent",
                }
            return _resp

if _module_enabled("relay"):

    @mcp.tool()
    async def slskd_get_relay_controller_downloads(
        token: str,
    ) -> dict[str, Any] | list[Any] | str:
        """Downloads a file from the connected controller If unexpected errors occur, call slskd_report_issue.

        token: The unique identifier for the request.
        """
        _path = f"/api/v0/relay/controller/downloads/{token}"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_relay_controller_downloads",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_relay_controller_downloads",
            }
        return _resp

if _module_enabled("relay"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_create_relay_controller_files(
            token: str,
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Uploads a file to the connected controller If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            token: The unique identifier for the request.
            """
            if not confirm:
                return {"preview": "POST /api/v0/relay/controller/files/{token}", "confirm": "Set confirm=True to execute this POST request."}
            _path = f"/api/v0/relay/controller/files/{token}"
            try:
                _resp = await _client.request(
                    "POST",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_create_relay_controller_files",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_create_relay_controller_files",
                }
            return _resp

if _module_enabled("relay"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_create_relay_controller_shares(
            token: str,
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Uploads share information to the connected controller If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            token: The unique identifier for the request.
            """
            if not confirm:
                return {"preview": "POST /api/v0/relay/controller/shares/{token}", "confirm": "Set confirm=True to execute this POST request."}
            _path = f"/api/v0/relay/controller/shares/{token}"
            try:
                _resp = await _client.request(
                    "POST",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_create_relay_controller_shares",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_create_relay_controller_shares",
                }
            return _resp

if _module_enabled("rooms"):

    @mcp.tool()
    async def slskd_list_rooms_available(
        fields: str = "",
        filter: str = "",
    ) -> dict[str, Any] | list[Any] | str:
        """Gets a list of rooms from the server. Returns a list. If unexpected errors occur, call slskd_report_issue.

        fields: Comma-separated field names to include. Omit for auto-compacted results.
        filter: Comma-separated key=value pairs to filter rows.
        """
        _path = "/api/v0/rooms/available"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_rooms_available",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_rooms_available",
            }
        if isinstance(_resp, list):
            return _filter_response(_resp, fields=fields, filter_expr=filter)
        return _resp

if _module_enabled("rooms"):

    @mcp.tool()
    async def slskd_list_rooms_joined(
    ) -> dict[str, Any] | list[Any] | str:
        """Gets all rooms If unexpected errors occur, call slskd_report_issue.

        """
        _path = "/api/v0/rooms/joined"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_rooms_joined",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_rooms_joined",
            }
        return _resp

if _module_enabled("rooms"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_create_rooms_joined(
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Joins a room If unexpected errors occur, call slskd_report_issue. Note: After joining, send messages with slskd_create_rooms_joined_messages and read messages with slskd_get_rooms_joined_messages.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "POST /api/v0/rooms/joined", "confirm": "Set confirm=True to execute this POST request."}
            _path = "/api/v0/rooms/joined"
            try:
                _resp = await _client.request(
                    "POST",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_create_rooms_joined",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_create_rooms_joined",
                }
            return _resp

if _module_enabled("rooms"):

    @mcp.tool()
    async def slskd_get_rooms_joined(
        roomName: str,
    ) -> dict[str, Any] | list[Any] | str:
        """Gets the specified room If unexpected errors occur, call slskd_report_issue.

        """
        _path = f"/api/v0/rooms/joined/{roomName}"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_rooms_joined",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_rooms_joined",
            }
        return _resp

if _module_enabled("rooms"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_delete_rooms_joined(
            roomName: str,
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Leaves a room If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "DELETE /api/v0/rooms/joined/{roomName}", "confirm": "Set confirm=True to execute this DELETE request."}
            _path = f"/api/v0/rooms/joined/{roomName}"
            try:
                _resp = await _client.request(
                    "DELETE",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_delete_rooms_joined",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_delete_rooms_joined",
                }
            return _resp

if _module_enabled("rooms"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_create_rooms_joined_members(
            roomName: str,
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Adds a member to a private room If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "POST /api/v0/rooms/joined/{roomName}/members", "confirm": "Set confirm=True to execute this POST request."}
            _path = f"/api/v0/rooms/joined/{roomName}/members"
            try:
                _resp = await _client.request(
                    "POST",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_create_rooms_joined_members",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_create_rooms_joined_members",
                }
            return _resp

if _module_enabled("rooms"):

    @mcp.tool()
    async def slskd_get_rooms_joined_messages(
        roomName: str,
        fields: str = "",
        filter: str = "",
    ) -> dict[str, Any] | list[Any] | str:
        """Gets the current list of messages for the specified room. Returns a list. If unexpected errors occur, call slskd_report_issue.

        fields: Comma-separated field names to include. Omit for auto-compacted results.
        filter: Comma-separated key=value pairs to filter rows.
        """
        _path = f"/api/v0/rooms/joined/{roomName}/messages"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_rooms_joined_messages",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_rooms_joined_messages",
            }
        if isinstance(_resp, list):
            return _filter_response(_resp, fields=fields, filter_expr=filter)
        return _resp

if _module_enabled("rooms"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_create_rooms_joined_messages(
            roomName: str,
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Sends a message to the specified room If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "POST /api/v0/rooms/joined/{roomName}/messages", "confirm": "Set confirm=True to execute this POST request."}
            _path = f"/api/v0/rooms/joined/{roomName}/messages"
            try:
                _resp = await _client.request(
                    "POST",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_create_rooms_joined_messages",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_create_rooms_joined_messages",
                }
            return _resp

if _module_enabled("rooms"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_create_rooms_joined_ticker(
            roomName: str,
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Sets a ticker for the specified room If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "POST /api/v0/rooms/joined/{roomName}/ticker", "confirm": "Set confirm=True to execute this POST request."}
            _path = f"/api/v0/rooms/joined/{roomName}/ticker"
            try:
                _resp = await _client.request(
                    "POST",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_create_rooms_joined_ticker",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_create_rooms_joined_ticker",
                }
            return _resp

if _module_enabled("rooms"):

    @mcp.tool()
    async def slskd_get_rooms_joined_users(
        roomName: str,
        fields: str = "",
        filter: str = "",
    ) -> dict[str, Any] | list[Any] | str:
        """Gets the current list of users for the specified room. Returns a list. If unexpected errors occur, call slskd_report_issue.

        fields: Comma-separated field names to include. Omit for auto-compacted results.
        filter: Comma-separated key=value pairs to filter rows.
        """
        _path = f"/api/v0/rooms/joined/{roomName}/users"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_rooms_joined_users",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_rooms_joined_users",
            }
        if isinstance(_resp, list):
            return _filter_response(_resp, fields=fields, filter_expr=filter)
        return _resp

if _module_enabled("searches"):

    @mcp.tool()
    async def slskd_list_searches(
        fields: str = "",
        filter: str = "",
    ) -> dict[str, Any] | list[Any] | str:
        """Gets the list of active and completed searches. Returns a list. If unexpected errors occur, call slskd_report_issue.

        fields: Comma-separated field names to include. Omit for auto-compacted results.
        filter: Comma-separated key=value pairs to filter rows.
        """
        _path = "/api/v0/searches"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_searches",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_searches",
            }
        if isinstance(_resp, list):
            return _filter_response(_resp, fields=fields, filter_expr=filter)
        return _resp

if _module_enabled("searches"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_create_search(
            fileLimit: int | None = None,
            filterResponses: bool | None = None,
            maximumPeerQueueLength: int | None = None,
            minimumPeerUploadSpeed: int | None = None,
            minimumResponseFileCount: int | None = None,
            responseLimit: int | None = None,
            searchText: str | None = None,
            searchTimeout: int | None = None,
            token: int | None = None,
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Performs a search for the specified request If unexpected errors occur, call slskd_report_issue. Note: Search is async. Poll slskd_get_search to check if state is 'Completed', then call slskd_get_searches_responses to get results.

            Requires confirm=True to execute. Set confirm=False to preview.
            fileLimit: Gets or sets the maximum number of file results to accept before the search is considered complete. (Default = 10,000).
            filterResponses: Gets or sets a value indicating whether responses are to be filtered. (Default = true).
            maximumPeerQueueLength: Gets or sets the maximum queue depth a peer may have in order for a response to be processed. (Default = 1000000).
            minimumPeerUploadSpeed: Gets or sets the minimum upload speed a peer must have in order for a response to be processed. (Default = 0).
            minimumResponseFileCount: Gets or sets the minimum number of files a response must contain in order to be processed. (Default = 1).
            responseLimit: Gets or sets the maximum number of search results to accept before the search is considered complete. (Default = 100).
            searchText: Gets or sets the search text.
            searchTimeout: Gets or sets the search timeout value, in milliseconds, used to determine when the search is complete. (Default = 15000).
            token: Gets or sets the search token.
            """
            if not confirm:
                return {"preview": "POST /api/v0/searches", "confirm": "Set confirm=True to execute this POST request."}
            _path = "/api/v0/searches"
            _body: dict[str, Any] = {}
            if fileLimit is not None:
                _body["fileLimit"] = fileLimit
            if filterResponses is not None:
                _body["filterResponses"] = filterResponses
            if maximumPeerQueueLength is not None:
                _body["maximumPeerQueueLength"] = maximumPeerQueueLength
            if minimumPeerUploadSpeed is not None:
                _body["minimumPeerUploadSpeed"] = minimumPeerUploadSpeed
            if minimumResponseFileCount is not None:
                _body["minimumResponseFileCount"] = minimumResponseFileCount
            if responseLimit is not None:
                _body["responseLimit"] = responseLimit
            if searchText is not None:
                _body["searchText"] = searchText
            if searchTimeout is not None:
                _body["searchTimeout"] = searchTimeout
            if token is not None:
                _body["token"] = token
            try:
                _resp = await _client.request(
                    "POST",
                    _path,
                    json_body=_body,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_create_search",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_create_search",
                }
            return _resp

if _module_enabled("searches"):

    @mcp.tool()
    async def slskd_get_search(
        id: str,
        includeResponses: bool = False,
    ) -> dict[str, Any] | list[Any] | str:
        """Gets the state of the search corresponding to the specified id If unexpected errors occur, call slskd_report_issue.

        id: The unique id of the search.
        includeResponses: A value indicating whether to include search responses in the response.
        """
        _path = f"/api/v0/searches/{id}"
        _params: dict[str, Any] = {}
        if includeResponses is not None:
            _params["includeResponses"] = includeResponses
        try:
            _resp = await _client.request(
                "GET",
                _path,
                params=_params,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_search",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_search",
            }
        return _resp

if _module_enabled("searches"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_update_search(
            id: str,
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Stops the search corresponding to the specified id If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            id: The unique id of the search.
            """
            if not confirm:
                return {"preview": "PUT /api/v0/searches/{id}", "confirm": "Set confirm=True to execute this PUT request."}
            _path = f"/api/v0/searches/{id}"
            try:
                _resp = await _client.request(
                    "PUT",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_update_search",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_update_search",
                }
            return _resp

if _module_enabled("searches"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_delete_search(
            id: str,
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Deletes the search corresponding to the specified id If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            id: The unique id of the search.
            """
            if not confirm:
                return {"preview": "DELETE /api/v0/searches/{id}", "confirm": "Set confirm=True to execute this DELETE request."}
            _path = f"/api/v0/searches/{id}"
            try:
                _resp = await _client.request(
                    "DELETE",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_delete_search",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_delete_search",
                }
            return _resp

if _module_enabled("searches"):

    @mcp.tool()
    async def slskd_get_searches_responses(
        id: str,
    ) -> dict[str, Any] | list[Any] | str:
        """Gets the state of the search corresponding to the specified id If unexpected errors occur, call slskd_report_issue.

        id: The unique id of the search.
        """
        _path = f"/api/v0/searches/{id}/responses"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_searches_responses",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_searches_responses",
            }
        return _resp

if _module_enabled("server"):

    @mcp.tool()
    async def slskd_list_server(
    ) -> dict[str, Any] | list[Any] | str:
        """Retrieves the current state of the server If unexpected errors occur, call slskd_report_issue. Note: Server states: Disconnected, Connected, LoggedIn, Connecting, LoggingIn, Disconnecting.

        """
        _path = "/api/v0/server"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_server",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_server",
            }
        return _resp

if _module_enabled("server"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_update_server(
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Connects the client If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "PUT /api/v0/server", "confirm": "Set confirm=True to execute this PUT request."}
            _path = "/api/v0/server"
            try:
                _resp = await _client.request(
                    "PUT",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_update_server",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_update_server",
                }
            return _resp

if _module_enabled("server"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_delete_server(
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Disconnects the client If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "DELETE /api/v0/server", "confirm": "Set confirm=True to execute this DELETE request."}
            _path = "/api/v0/server"
            try:
                _resp = await _client.request(
                    "DELETE",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_delete_server",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_delete_server",
                }
            return _resp

if _module_enabled("session"):

    @mcp.tool()
    async def slskd_list_session(
    ) -> dict[str, Any] | list[Any] | str:
        """Checks whether the provided authentication is valid If unexpected errors occur, call slskd_report_issue.

        """
        _path = "/api/v0/session"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_session",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_session",
            }
        return _resp

if _module_enabled("session"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_create_session(
            username: str | None = None,
            password: str | None = None,
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Logs in If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "POST /api/v0/session", "confirm": "Set confirm=True to execute this POST request."}
            _path = "/api/v0/session"
            _body: dict[str, Any] = {}
            if username is not None:
                _body["username"] = username
            if password is not None:
                _body["password"] = password
            try:
                _resp = await _client.request(
                    "POST",
                    _path,
                    json_body=_body,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_create_session",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_create_session",
                }
            return _resp

if _module_enabled("session"):

    @mcp.tool()
    async def slskd_list_session_enabled(
    ) -> dict[str, Any] | list[Any] | str:
        """Checks whether security is enabled If unexpected errors occur, call slskd_report_issue.

        """
        _path = "/api/v0/session/enabled"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_session_enabled",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_session_enabled",
            }
        return _resp

if _module_enabled("shares"):

    @mcp.tool()
    async def slskd_list_shares(
    ) -> dict[str, Any] | list[Any] | str:
        """Gets the current list of shares If unexpected errors occur, call slskd_report_issue.

        """
        _path = "/api/v0/shares"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_shares",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_shares",
            }
        return _resp

if _module_enabled("shares"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_update_shares(
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Initiates a scan of the configured shares If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "PUT /api/v0/shares", "confirm": "Set confirm=True to execute this PUT request."}
            _path = "/api/v0/shares"
            try:
                _resp = await _client.request(
                    "PUT",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_update_shares",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_update_shares",
                }
            return _resp

if _module_enabled("shares"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_delete_shares(
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Cancels a share scan, if one is running If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "DELETE /api/v0/shares", "confirm": "Set confirm=True to execute this DELETE request."}
            _path = "/api/v0/shares"
            try:
                _resp = await _client.request(
                    "DELETE",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_delete_shares",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_delete_shares",
                }
            return _resp

if _module_enabled("shares"):

    @mcp.tool()
    async def slskd_list_shares_contents(
        fields: str = "",
        filter: str = "",
    ) -> dict[str, Any] | list[Any] | str:
        """Returns a list of all shared directories and files. Returns a list. If unexpected errors occur, call slskd_report_issue.

        fields: Comma-separated field names to include. Omit for auto-compacted results.
        filter: Comma-separated key=value pairs to filter rows.
        """
        _path = "/api/v0/shares/contents"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_shares_contents",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_shares_contents",
            }
        if isinstance(_resp, list):
            return _filter_response(_resp, fields=fields, filter_expr=filter)
        return _resp

if _module_enabled("shares"):

    @mcp.tool()
    async def slskd_get_share(
        id: str,
    ) -> dict[str, Any] | list[Any] | str:
        """Gets the share associated with the specified <see paramref="id" /> If unexpected errors occur, call slskd_report_issue.

        id: The id of the share.
        """
        _path = f"/api/v0/shares/{id}"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_share",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_share",
            }
        return _resp

if _module_enabled("shares"):

    @mcp.tool()
    async def slskd_get_shares_contents(
        id: str,
        fields: str = "",
        filter: str = "",
    ) -> dict[str, Any] | list[Any] | str:
        """Gets the contents of the share associated with the specified <see paramref="id" />. Returns a list. If unexpected errors occur, call slskd_report_issue.

        id: The id of the share.
        fields: Comma-separated field names to include. Omit for auto-compacted results.
        filter: Comma-separated key=value pairs to filter rows.
        """
        _path = f"/api/v0/shares/{id}/contents"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_shares_contents",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_shares_contents",
            }
        if isinstance(_resp, list):
            return _filter_response(_resp, fields=fields, filter_expr=filter)
        return _resp

if _module_enabled("telemetry"):

    @mcp.tool()
    async def slskd_list_telemetry_metrics(
    ) -> dict[str, Any] | list[Any] | str:
        """Gets all application metrics If unexpected errors occur, call slskd_report_issue.

        """
        _path = "/api/v0/telemetry/metrics"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_telemetry_metrics",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_telemetry_metrics",
            }
        return _resp

if _module_enabled("telemetry"):

    @mcp.tool()
    async def slskd_list_telemetry_metrics_kpis(
    ) -> dict[str, Any] | list[Any] | str:
        """Gets gets key performance indicators (KPIs) for the application If unexpected errors occur, call slskd_report_issue.

        """
        _path = "/api/v0/telemetry/metrics/kpis"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_telemetry_metrics_kpis",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_telemetry_metrics_kpis",
            }
        return _resp

if _module_enabled("telemetry"):

    @mcp.tool()
    async def slskd_list_telemetry_reports_transfers_directories(
        fields: str = "",
        filter: str = "",
        start: str | None = None,
        end: str | None = None,
        username: str | None = None,
        limit: int = 25,
        offset: int = 0,
    ) -> dict[str, Any] | list[Any] | str:
        """Gets the top N most frequently downloaded directories by total count and distinct users. Returns a list. If unexpected errors occur, call slskd_report_issue.

        start: The start time of the window (default: 12/30/2025).
        end: The end time of the window (default: now).
        username: An optional username by which to filter records.
        limit: The number of records to return (Default: 25).
        offset: The record offset (if paginating).
        fields: Comma-separated field names to include. Omit for auto-compacted results.
        filter: Comma-separated key=value pairs to filter rows.
        """
        _path = "/api/v0/telemetry/reports/transfers/directories"
        _params: dict[str, Any] = {}
        if start is not None:
            _params["start"] = start
        if end is not None:
            _params["end"] = end
        if username is not None:
            _params["username"] = username
        if limit is not None:
            _params["limit"] = limit
        if offset is not None:
            _params["offset"] = offset
        try:
            _resp = await _client.request(
                "GET",
                _path,
                params=_params,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_telemetry_reports_transfers_directories",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_telemetry_reports_transfers_directories",
            }
        if isinstance(_resp, list):
            return _filter_response(_resp, fields=fields, filter_expr=filter)
        return _resp

if _module_enabled("telemetry"):

    @mcp.tool()
    async def slskd_list_telemetry_reports_transfers_exceptions(
        fields: str = "",
        filter: str = "",
        direction: str | None = None,
        start: str | None = None,
        end: str | None = None,
        username: str | None = None,
        sortOrder: str = "DESC",
        limit: int = 25,
        offset: int = 0,
    ) -> dict[str, Any] | list[Any] | str:
        """Gets a list of transfer exceptions by direction. Returns a list. If unexpected errors occur, call slskd_report_issue.

        direction: The direction.
        start: The start time.
        end: The end time.
        username: An optional username by which to filter exceptions.
        sortOrder: The sort order (ASC, DESC. Default: DESC).
        limit: The number of records to return (Default: 25).
        offset: The record offset (if paginating).
        fields: Comma-separated field names to include. Omit for auto-compacted results.
        filter: Comma-separated key=value pairs to filter rows.
        """
        _path = "/api/v0/telemetry/reports/transfers/exceptions"
        _params: dict[str, Any] = {}
        if direction is not None:
            _params["direction"] = direction
        if start is not None:
            _params["start"] = start
        if end is not None:
            _params["end"] = end
        if username is not None:
            _params["username"] = username
        if sortOrder is not None:
            _params["sortOrder"] = sortOrder
        if limit is not None:
            _params["limit"] = limit
        if offset is not None:
            _params["offset"] = offset
        try:
            _resp = await _client.request(
                "GET",
                _path,
                params=_params,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_telemetry_reports_transfers_exceptions",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_telemetry_reports_transfers_exceptions",
            }
        if isinstance(_resp, list):
            return _filter_response(_resp, fields=fields, filter_expr=filter)
        return _resp

if _module_enabled("telemetry"):

    @mcp.tool()
    async def slskd_list_telemetry_reports_transfers_exceptions_pareto(
        fields: str = "",
        filter: str = "",
        direction: str | None = None,
        start: str | None = None,
        end: str | None = None,
        username: str | None = None,
        limit: int = 25,
        offset: int = 0,
    ) -> dict[str, Any] | list[Any] | str:
        """Gets the top N exceptions by total count and direction. Returns a list. If unexpected errors occur, call slskd_report_issue.

        direction: The direction.
        start: The start time.
        end: The end time.
        username: An optional username by which to filter exceptions.
        limit: The number of records to return (Default: 25).
        offset: The record offset (if paginating).
        fields: Comma-separated field names to include. Omit for auto-compacted results.
        filter: Comma-separated key=value pairs to filter rows.
        """
        _path = "/api/v0/telemetry/reports/transfers/exceptions/pareto"
        _params: dict[str, Any] = {}
        if direction is not None:
            _params["direction"] = direction
        if start is not None:
            _params["start"] = start
        if end is not None:
            _params["end"] = end
        if username is not None:
            _params["username"] = username
        if limit is not None:
            _params["limit"] = limit
        if offset is not None:
            _params["offset"] = offset
        try:
            _resp = await _client.request(
                "GET",
                _path,
                params=_params,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_telemetry_reports_transfers_exceptions_pareto",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_telemetry_reports_transfers_exceptions_pareto",
            }
        if isinstance(_resp, list):
            return _filter_response(_resp, fields=fields, filter_expr=filter)
        return _resp

if _module_enabled("telemetry"):

    @mcp.tool()
    async def slskd_list_telemetry_reports_transfers_histogram(
        start: str | None = None,
        end: str | None = None,
        interval: int = 60,
        direction: str | None = None,
        username: str | None = None,
    ) -> dict[str, Any] | list[Any] | str:
        """Gets a histogram of all transfer activity over the specified timeframe, aggregated into fixed size time intervals
and grouped by direction and final state If unexpected errors occur, call slskd_report_issue.

        start: The start time of the window (default: 7 days ago).
        end: The end time of the window (default: now).
        interval: The interval, in minutes (default: 60).
        direction: An optional direction (Upload, Download) by which to filter records.
        username: An optional username by which to filter records.
        """
        _path = "/api/v0/telemetry/reports/transfers/histogram"
        _params: dict[str, Any] = {}
        if start is not None:
            _params["start"] = start
        if end is not None:
            _params["end"] = end
        if interval is not None:
            _params["interval"] = interval
        if direction is not None:
            _params["direction"] = direction
        if username is not None:
            _params["username"] = username
        try:
            _resp = await _client.request(
                "GET",
                _path,
                params=_params,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_telemetry_reports_transfers_histogram",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_telemetry_reports_transfers_histogram",
            }
        return _resp

if _module_enabled("telemetry"):

    @mcp.tool()
    async def slskd_list_telemetry_reports_transfers_leaderboard(
        fields: str = "",
        filter: str = "",
        direction: str | None = None,
        start: str | None = None,
        end: str | None = None,
        sortBy: str = "Count",
        sortOrder: str = "DESC",
        limit: int = 25,
        offset: int = 0,
    ) -> dict[str, Any] | list[Any] | str:
        """Gets the top N user summaries by count, total bytes, or average speed. Returns a list. If unexpected errors occur, call slskd_report_issue.

        direction: The direction (Upload, Download).
        start: The start time of the window (default: 12/30/2025).
        end: The end time of the window (default: now).
        sortBy: The property by which to sort (Count, TotalBytes, AverageSpeed. Default: Count).
        sortOrder: The sort order (ASC, DESC. Default: DESC).
        limit: The number of records to return (Default: 25).
        offset: The record offset (if paginating).
        fields: Comma-separated field names to include. Omit for auto-compacted results.
        filter: Comma-separated key=value pairs to filter rows.
        """
        _path = "/api/v0/telemetry/reports/transfers/leaderboard"
        _params: dict[str, Any] = {}
        if direction is not None:
            _params["direction"] = direction
        if start is not None:
            _params["start"] = start
        if end is not None:
            _params["end"] = end
        if sortBy is not None:
            _params["sortBy"] = sortBy
        if sortOrder is not None:
            _params["sortOrder"] = sortOrder
        if limit is not None:
            _params["limit"] = limit
        if offset is not None:
            _params["offset"] = offset
        try:
            _resp = await _client.request(
                "GET",
                _path,
                params=_params,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_telemetry_reports_transfers_leaderboard",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_telemetry_reports_transfers_leaderboard",
            }
        if isinstance(_resp, list):
            return _filter_response(_resp, fields=fields, filter_expr=filter)
        return _resp

if _module_enabled("telemetry"):

    @mcp.tool()
    async def slskd_list_telemetry_reports_transfers_summary(
        start: str | None = None,
        end: str | None = None,
        direction: str | None = None,
        username: str | None = None,
    ) -> dict[str, Any] | list[Any] | str:
        """Gets a summary of all transfer activity over the specified timeframe, grouped by direction and final state If unexpected errors occur, call slskd_report_issue.

        start: The start time of the window (default: 7 days ago).
        end: The end time of the window (default: now).
        direction: An optional direction (Upload, Download) by which to filter records.
        username: An optional username by which to filter records.
        """
        _path = "/api/v0/telemetry/reports/transfers/summary"
        _params: dict[str, Any] = {}
        if start is not None:
            _params["start"] = start
        if end is not None:
            _params["end"] = end
        if direction is not None:
            _params["direction"] = direction
        if username is not None:
            _params["username"] = username
        try:
            _resp = await _client.request(
                "GET",
                _path,
                params=_params,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_telemetry_reports_transfers_summary",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_telemetry_reports_transfers_summary",
            }
        return _resp

if _module_enabled("telemetry"):

    @mcp.tool()
    async def slskd_get_telemetry_reports_transfers_users(
        username: str,
        start: str | None = None,
        end: str | None = None,
    ) -> dict[str, Any] | list[Any] | str:
        """Gets detailed transfer activity for the specified user If unexpected errors occur, call slskd_report_issue.

        username: The username of the user.
        start: The start time of the summary window (default: 7 days ago).
        end: The end time of the summary window (default: now).
        """
        _path = f"/api/v0/telemetry/reports/transfers/users/{username}"
        _params: dict[str, Any] = {}
        if start is not None:
            _params["start"] = start
        if end is not None:
            _params["end"] = end
        try:
            _resp = await _client.request(
                "GET",
                _path,
                params=_params,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_telemetry_reports_transfers_users",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_telemetry_reports_transfers_users",
            }
        return _resp

if _module_enabled("transfers"):

    @mcp.tool()
    async def slskd_list_transfers_downloads(
        fields: str = "",
        filter: str = "",
        includeRemoved: bool = False,
    ) -> dict[str, Any] | list[Any] | str:
        """Gets all downloads. Returns a list. If unexpected errors occur, call slskd_report_issue. Note: Transfer states: Requested, Queued, Initializing, InProgress, Completed, Succeeded, Cancelled, TimedOut, Errored, Rejected, Aborted.

        fields: Comma-separated field names to include. Omit for auto-compacted results.
        filter: Comma-separated key=value pairs to filter rows.
        """
        _path = "/api/v0/transfers/downloads"
        _params: dict[str, Any] = {}
        if includeRemoved is not None:
            _params["includeRemoved"] = includeRemoved
        try:
            _resp = await _client.request(
                "GET",
                _path,
                params=_params,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_transfers_downloads",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_transfers_downloads",
            }
        if isinstance(_resp, list):
            return _filter_response(_resp, fields=fields, filter_expr=filter)
        return _resp

if _module_enabled("transfers"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_delete_transfers_downloads_all_completed(
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Removes all completed downloads, regardless of whether they failed or succeeded If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "DELETE /api/v0/transfers/downloads/all/completed", "confirm": "Set confirm=True to execute this DELETE request."}
            _path = "/api/v0/transfers/downloads/all/completed"
            try:
                _resp = await _client.request(
                    "DELETE",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_delete_transfers_downloads_all_completed",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_delete_transfers_downloads_all_completed",
                }
            return _resp

if _module_enabled("transfers"):

    @mcp.tool()
    async def slskd_get_transfers_downloads(
        username: str,
    ) -> dict[str, Any] | list[Any] | str:
        """Gets all downloads for the specified username If unexpected errors occur, call slskd_report_issue.

        """
        _path = f"/api/v0/transfers/downloads/{username}"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_transfers_downloads",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_transfers_downloads",
            }
        return _resp

if _module_enabled("transfers"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_create_transfers_downloads(
            username: str,
            body: list[dict],
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Enqueues the specified download If unexpected errors occur, call slskd_report_issue. Note: After queueing, monitor progress with slskd_list_transfers_downloads. Clear completed downloads with slskd_delete_transfers_downloads_all_completed.

            Requires confirm=True to execute. Set confirm=False to preview.
            username: The username of the download source.
            body: Request body (array)
            """
            if not confirm:
                return {"preview": "POST /api/v0/transfers/downloads/{username}", "confirm": "Set confirm=True to execute this POST request."}
            _path = f"/api/v0/transfers/downloads/{username}"
            try:
                _resp = await _client.request(
                    "POST",
                    _path,
                    json_body=body,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_create_transfers_downloads",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_create_transfers_downloads",
                }
            return _resp

if _module_enabled("transfers"):

    @mcp.tool()
    async def slskd_get_transfer_download(
        username: str,
        id: str,
    ) -> dict[str, Any] | list[Any] | str:
        """Get transfer download by ID If unexpected errors occur, call slskd_report_issue.

        """
        _path = f"/api/v0/transfers/downloads/{username}/{id}"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_transfer_download",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_transfer_download",
            }
        return _resp

if _module_enabled("transfers"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_delete_transfers_downloads(
            username: str,
            id: str,
            remove: bool = False,
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Cancels the specified download If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            username: The username of the download source.
            id: The id of the download.
            remove: A value indicating whether the tracked download should be removed after cancellation.
            """
            if not confirm:
                return {"preview": "DELETE /api/v0/transfers/downloads/{username}/{id}", "confirm": "Set confirm=True to execute this DELETE request."}
            _path = f"/api/v0/transfers/downloads/{username}/{id}"
            _params: dict[str, Any] = {}
            if remove is not None:
                _params["remove"] = remove
            try:
                _resp = await _client.request(
                    "DELETE",
                    _path,
                    params=_params,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_delete_transfers_downloads",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_delete_transfers_downloads",
                }
            return _resp

if _module_enabled("transfers"):

    @mcp.tool()
    async def slskd_get_transfers_downloads_position(
        username: str,
        id: str,
    ) -> dict[str, Any] | list[Any] | str:
        """Gets the download for the specified username matching the specified filename, and requests
the current place in the remote queue of the specified download If unexpected errors occur, call slskd_report_issue.

        username: The username of the download source.
        id: The id of the download.
        """
        _path = f"/api/v0/transfers/downloads/{username}/{id}/position"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_transfers_downloads_position",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_transfers_downloads_position",
            }
        return _resp

if _module_enabled("transfers"):

    @mcp.tool()
    async def slskd_list_transfers_uploads(
        fields: str = "",
        filter: str = "",
        includeRemoved: bool = False,
    ) -> dict[str, Any] | list[Any] | str:
        """Gets all uploads. Returns a list. If unexpected errors occur, call slskd_report_issue. Note: Transfer states: Requested, Queued, Initializing, InProgress, Completed, Succeeded, Cancelled, TimedOut, Errored, Rejected, Aborted.

        fields: Comma-separated field names to include. Omit for auto-compacted results.
        filter: Comma-separated key=value pairs to filter rows.
        """
        _path = "/api/v0/transfers/uploads"
        _params: dict[str, Any] = {}
        if includeRemoved is not None:
            _params["includeRemoved"] = includeRemoved
        try:
            _resp = await _client.request(
                "GET",
                _path,
                params=_params,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_list_transfers_uploads",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_list_transfers_uploads",
            }
        if isinstance(_resp, list):
            return _filter_response(_resp, fields=fields, filter_expr=filter)
        return _resp

if _module_enabled("transfers"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_delete_transfers_uploads_all_completed(
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Removes all completed uploads, regardless of whether they failed or succeeded If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            """
            if not confirm:
                return {"preview": "DELETE /api/v0/transfers/uploads/all/completed", "confirm": "Set confirm=True to execute this DELETE request."}
            _path = "/api/v0/transfers/uploads/all/completed"
            try:
                _resp = await _client.request(
                    "DELETE",
                    _path,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_delete_transfers_uploads_all_completed",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_delete_transfers_uploads_all_completed",
                }
            return _resp

if _module_enabled("transfers"):

    @mcp.tool()
    async def slskd_get_transfers_uploads(
        username: str,
    ) -> dict[str, Any] | list[Any] | str:
        """Gets all uploads for the specified username If unexpected errors occur, call slskd_report_issue.

        """
        _path = f"/api/v0/transfers/uploads/{username}"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_transfers_uploads",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_transfers_uploads",
            }
        return _resp

if _module_enabled("transfers"):

    @mcp.tool()
    async def slskd_get_transfer_upload(
        username: str,
        id: str,
    ) -> dict[str, Any] | list[Any] | str:
        """Gets the upload for the specified username matching the specified filename If unexpected errors occur, call slskd_report_issue.

        username: The username of the upload destination.
        id: The id of the upload.
        """
        _path = f"/api/v0/transfers/uploads/{username}/{id}"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_transfer_upload",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_transfer_upload",
            }
        return _resp

if _module_enabled("transfers"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_delete_transfers_uploads(
            username: str,
            id: str,
            remove: bool = False,
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Cancels the specified upload If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            username: The username of the upload destination.
            id: The id of the upload.
            remove: A value indicating whether the tracked upload should be removed after cancellation.
            """
            if not confirm:
                return {"preview": "DELETE /api/v0/transfers/uploads/{username}/{id}", "confirm": "Set confirm=True to execute this DELETE request."}
            _path = f"/api/v0/transfers/uploads/{username}/{id}"
            _params: dict[str, Any] = {}
            if remove is not None:
                _params["remove"] = remove
            try:
                _resp = await _client.request(
                    "DELETE",
                    _path,
                    params=_params,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_delete_transfers_uploads",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_delete_transfers_uploads",
                }
            return _resp

if _module_enabled("users"):

    @mcp.tool()
    async def slskd_get_users_browse(
        username: str,
        fields: str = "",
        filter: str = "",
    ) -> dict[str, Any] | list[Any] | str:
        """Retrieves the files shared by the specified username. Returns a list. If unexpected errors occur, call slskd_report_issue. Note: To download files from results, pass them to slskd_create_transfers_downloads with the username.

        username: The username of the user.
        fields: Comma-separated field names to include. Omit for auto-compacted results.
        filter: Comma-separated key=value pairs to filter rows.
        """
        _path = f"/api/v0/users/{username}/browse"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_users_browse",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_users_browse",
            }
        if isinstance(_resp, list):
            return _filter_response(_resp, fields=fields, filter_expr=filter)
        return _resp

if _module_enabled("users"):

    @mcp.tool()
    async def slskd_get_users_browse_status(
        username: str,
    ) -> dict[str, Any] | list[Any] | str:
        """Retrieves the status of the current browse operation for the specified username, if any If unexpected errors occur, call slskd_report_issue.

        username: The username of the user.
        """
        _path = f"/api/v0/users/{username}/browse/status"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_users_browse_status",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_users_browse_status",
            }
        return _resp

if _module_enabled("users"):
    if not SLSKD_READ_ONLY:

        @mcp.tool()
        async def slskd_create_users_directory(
            username: str,
            fields: str = "",
            filter: str = "",
            directory: str | None = None,
            confirm: bool = False,
        ) -> dict[str, Any] | list[Any] | str:
            """Retrieves the files from the specified directory from the specified username. Returns a list. If unexpected errors occur, call slskd_report_issue.

            Requires confirm=True to execute. Set confirm=False to preview.
            username: The username of the user.
            fields: Comma-separated field names to include. Omit for auto-compacted results.
            filter: Comma-separated key=value pairs to filter rows.
            """
            if not confirm:
                return {"preview": "POST /api/v0/users/{username}/directory", "confirm": "Set confirm=True to execute this POST request."}
            _path = f"/api/v0/users/{username}/directory"
            _body: dict[str, Any] = {}
            if directory is not None:
                _body["directory"] = directory
            try:
                _resp = await _client.request(
                    "POST",
                    _path,
                    json_body=_body,
                )
            except httpx.HTTPStatusError as exc:
                return {
                    "error": True,
                    "source": "slskd_api",
                    "status": exc.response.status_code,
                    "message": exc.response.text[:500],
                    "tool": "slskd_create_users_directory",
                }
            except httpx.RequestError as exc:
                return {
                    "error": True,
                    "source": "network",
                    "status": 0,
                    "message": str(exc)[:500],
                    "tool": "slskd_create_users_directory",
                }
            if isinstance(_resp, list):
                return _filter_response(_resp, fields=fields, filter_expr=filter)
            return _resp

if _module_enabled("users"):

    @mcp.tool()
    async def slskd_get_users_endpoint(
        username: str,
    ) -> dict[str, Any] | list[Any] | str:
        """Retrieves the address of the specified username If unexpected errors occur, call slskd_report_issue.

        username: The username of the user.
        """
        _path = f"/api/v0/users/{username}/endpoint"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_users_endpoint",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_users_endpoint",
            }
        return _resp

if _module_enabled("users"):

    @mcp.tool()
    async def slskd_get_users_info(
        username: str,
    ) -> dict[str, Any] | list[Any] | str:
        """Retrieves information about the specified username If unexpected errors occur, call slskd_report_issue.

        username: The username of the user.
        """
        _path = f"/api/v0/users/{username}/info"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_users_info",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_users_info",
            }
        return _resp

if _module_enabled("users"):

    @mcp.tool()
    async def slskd_get_users_status(
        username: str,
    ) -> dict[str, Any] | list[Any] | str:
        """Retrieves status for the specified username If unexpected errors occur, call slskd_report_issue. Note: Presence values: Offline, Away, Online.

        username: The username of the user.
        """
        _path = f"/api/v0/users/{username}/status"
        try:
            _resp = await _client.request(
                "GET",
                _path,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_get_users_status",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_get_users_status",
            }
        return _resp

