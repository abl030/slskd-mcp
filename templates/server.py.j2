"""slskd MCP Server (auto-generated).

Generated for slskd API {{ slskd_version }}.
Total tools: ~{{ tool_count }}

DO NOT EDIT THIS FILE. All changes must be made in the generator or templates.
"""

from __future__ import annotations

import base64
import json
import os
from typing import Any

import httpx
from fastmcp import FastMCP

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------

SLSKD_URL = os.environ.get("SLSKD_URL", "http://localhost:5030")
SLSKD_API_KEY = os.environ.get("SLSKD_API_KEY", "")
SLSKD_MODULES = os.environ.get("SLSKD_MODULES", "")
SLSKD_READ_ONLY = os.environ.get("SLSKD_READ_ONLY", "false").lower() == "true"

# Parse enabled modules
_enabled_modules: set[str] | None = None
if SLSKD_MODULES:
    _enabled_modules = {m.strip() for m in SLSKD_MODULES.split(",") if m.strip()}

ALL_MODULES = {{ modules.keys() | list | sort }}


def _module_enabled(module: str | None) -> bool:
    """Check if a module is enabled."""
    if module is None:
        return True
    if _enabled_modules is not None:
        return module in _enabled_modules
    return True


# ---------------------------------------------------------------------------
# HTTP Client
# ---------------------------------------------------------------------------

class SlskdClient:
    """Async HTTP client for the slskd API."""

    def __init__(self) -> None:
        self._client: httpx.AsyncClient | None = None

    async def _get_client(self) -> httpx.AsyncClient:
        if self._client is None or self._client.is_closed:
            self._client = httpx.AsyncClient(
                base_url=SLSKD_URL,
                headers={"X-Api-Key": SLSKD_API_KEY},
                timeout=30.0,
                verify=False,
            )
        return self._client

    async def request(
        self,
        method: str,
        path: str,
        params: dict[str, Any] | None = None,
        json_body: dict[str, Any] | list[Any] | None = None,
    ) -> dict[str, Any] | list[Any]:
        client = await self._get_client()
        response = await client.request(
            method,
            path,
            params=params,
            json=json_body,
        )
        response.raise_for_status()
        if response.status_code == 204 or not response.content:
            return {"status": "success", "message": "No content"}
        return response.json()


_client = SlskdClient()

# ---------------------------------------------------------------------------
# Base64 encoding helper
# ---------------------------------------------------------------------------

def _b64encode(value: str) -> str:
    """Base64-encode a string for use in slskd path parameters."""
    return base64.b64encode(value.encode("utf-8")).decode("ascii")


# ---------------------------------------------------------------------------
# Response helpers
# ---------------------------------------------------------------------------

def _compact_value(v: Any) -> Any:
    """Compact a single value for list-response auto-compaction."""
    if isinstance(v, dict) and len(v) > 4:
        if "id" in v:
            return {"id": v["id"]}
        return {"_keys": len(v)}
    if isinstance(v, list) and v and isinstance(v[0], dict):
        return f"[{len(v)} items]"
    return v


def _compact_object(row: dict[str, Any]) -> dict[str, Any]:
    """Auto-compact nested objects in a single row."""
    return {k: _compact_value(v) for k, v in row.items()}


def _filter_response(
    data: list[dict[str, Any]],
    fields: str = "",
    filter_expr: str = "",
) -> dict[str, Any]:
    """Filter list response with field selection, row filtering, and auto-compaction."""
    result = data
    if filter_expr:
        for pair in filter_expr.split(","):
            pair = pair.strip()
            if "=" not in pair:
                continue
            k, v = pair.split("=", 1)
            result = [
                row for row in result
                if str(row.get(k.strip())) == v.strip()
            ]
    if fields:
        field_set = {f.strip() for f in fields.split(",")} | {"id"}
        result = [{k: v for k, v in row.items() if k in field_set} for row in result]
    else:
        result = [_compact_object(row) for row in result]
    return {"summary": f"Found {len(result)} items", "count": len(result), "data": result}


# ---------------------------------------------------------------------------
# FastMCP Server
# ---------------------------------------------------------------------------

mcp = FastMCP("slskd-mcp")

# ---------------------------------------------------------------------------
# Always-registered tools
# ---------------------------------------------------------------------------

@mcp.tool()
async def slskd_get_overview() -> dict[str, Any]:
    """Get a system overview: server state, transfer counts, search activity.

    Returns a unified summary in a single call.
    """
    import asyncio
    server, downloads, uploads, searches = await asyncio.gather(
        _client.request("GET", "/api/v0/server"),
        _client.request("GET", "/api/v0/transfers/downloads"),
        _client.request("GET", "/api/v0/transfers/uploads"),
        _client.request("GET", "/api/v0/searches"),
    )
    return {
        "server": server,
        "downloadCount": len(downloads) if isinstance(downloads, list) else 0,
        "uploadCount": len(uploads) if isinstance(uploads, list) else 0,
        "searchCount": len(searches) if isinstance(searches, list) else 0,
    }


@mcp.tool()
async def slskd_search_tools(keyword: str) -> dict[str, Any]:
    """Search for tools by keyword (e.g. 'search', 'download', 'transfer').

    Use this tool first to find the right tool before trying to call it directly.
    """
    keyword_lower = keyword.lower()
    matches = []
    for tool in mcp._tool_manager._tools.values():
        if keyword_lower in tool.name.lower() or keyword_lower in (tool.description or "").lower():
            matches.append({"name": tool.name, "description": (tool.description or "")[:120]})
    return {"summary": f"Found {len(matches)} tools matching '{keyword}'", "matches": matches}


@mcp.tool()
async def slskd_report_issue(
    tool_name: str,
    error_message: str,
    parameters_used: str = "",
    notes: str = "",
) -> str:
    """Generate a structured bug report for unexpected errors.

    Returns a ready-to-paste `gh issue create` command. Makes no HTTP calls.
    If any tool returns an unexpected error, call this to report it.
    """
    body = f"""## Bug Report

**Tool:** `{tool_name}`
**Error:** `{error_message}`
**Parameters:** `{parameters_used}`

### Notes
{notes}

### Environment
- slskd MCP Server
- Generated from OpenAPI spec
"""
    title = f"Bug: {tool_name} â€” {error_message[:60]}"
    cmd = f'gh issue create --repo abl030/slskd-mcp --title "{title}" --body "$(cat <<\'GHEOF\'\n{body}\nGHEOF\n)"'
    return cmd


# ---------------------------------------------------------------------------
# Generated tools
# ---------------------------------------------------------------------------

{% for tool in tools %}
{% set indent = "" %}
{% if tool.module %}
if _module_enabled("{{ tool.module }}"):
{% set indent = "    " %}
{% endif %}
{% if tool.is_mutation %}
{{ indent }}if not SLSKD_READ_ONLY:
{% set indent = indent + "    " %}
{% endif %}

{{ indent }}@mcp.tool()
{% set required_params = tool.params | selectattr("required") | list %}
{% set optional_params = tool.params | rejectattr("required") | list %}
{% if tool.is_mutation %}
{{ indent }}async def {{ tool.name }}(
{% for p in required_params %}
{{ indent }}    {{ p.name }}: {{ p.type }},
{% endfor %}
{% if tool.is_list %}
{{ indent }}    fields: str = "",
{{ indent }}    filter: str = "",
{% endif %}
{% for p in optional_params %}
{% if p.default is none %}
{{ indent }}    {{ p.name }}: {{ p.type }} | None = None,
{% elif p.default is sameas true %}
{{ indent }}    {{ p.name }}: {{ p.type }} = True,
{% elif p.default is sameas false %}
{{ indent }}    {{ p.name }}: {{ p.type }} = False,
{% elif p.default is string %}
{{ indent }}    {{ p.name }}: {{ p.type }} = "{{ p.default }}",
{% else %}
{{ indent }}    {{ p.name }}: {{ p.type }} = {{ p.default }},
{% endif %}
{% endfor %}
{{ indent }}    confirm: bool = False,
{{ indent }}) -> dict[str, Any] | list[Any] | str:
{{ indent }}    """{{ tool.description }}

{{ indent }}    Requires confirm=True to execute. Set confirm=False to preview.
{% for p in tool.params %}
{% if p.description %}
{{ indent }}    {{ p.name }}: {{ p.description }}
{% endif %}
{% endfor %}
{% if tool.is_list %}
{{ indent }}    fields: Comma-separated field names to include. Omit for auto-compacted results.
{{ indent }}    filter: Comma-separated key=value pairs to filter rows.
{% endif %}
{{ indent }}    """
{{ indent }}    if not confirm:
{{ indent }}        return {"preview": "{{ tool.method | upper }} {{ tool.path }}", "confirm": "Set confirm=True to execute this {{ tool.method | upper }} request."}
{% else %}
{{ indent }}async def {{ tool.name }}(
{% for p in required_params %}
{{ indent }}    {{ p.name }}: {{ p.type }},
{% endfor %}
{% if tool.is_list %}
{{ indent }}    fields: str = "",
{{ indent }}    filter: str = "",
{% endif %}
{% for p in optional_params %}
{% if p.default is none %}
{{ indent }}    {{ p.name }}: {{ p.type }} | None = None,
{% elif p.default is sameas true %}
{{ indent }}    {{ p.name }}: {{ p.type }} = True,
{% elif p.default is sameas false %}
{{ indent }}    {{ p.name }}: {{ p.type }} = False,
{% elif p.default is string %}
{{ indent }}    {{ p.name }}: {{ p.type }} = "{{ p.default }}",
{% else %}
{{ indent }}    {{ p.name }}: {{ p.type }} = {{ p.default }},
{% endif %}
{% endfor %}
{{ indent }}) -> dict[str, Any] | list[Any] | str:
{{ indent }}    """{{ tool.description }}

{% for p in tool.params %}
{% if p.description %}
{{ indent }}    {{ p.name }}: {{ p.description }}
{% endif %}
{% endfor %}
{% if tool.is_list %}
{{ indent }}    fields: Comma-separated field names to include. Omit for auto-compacted results.
{{ indent }}    filter: Comma-separated key=value pairs to filter rows.
{% endif %}
{{ indent }}    """
{% endif %}
{% set path_params = tool.params | selectattr("location", "equalto", "path") | list %}
{% set query_params = tool.params | selectattr("location", "equalto", "query") | list %}
{% set body_params = tool.params | selectattr("location", "equalto", "body") | list %}
{% if tool.has_base64_params %}
{% for p in path_params %}
{% if p.name in ["base64SubdirectoryName", "base64FileName"] %}
{{ indent }}    {{ p.name }} = _b64encode({{ p.name }})
{% endif %}
{% endfor %}
{% endif %}
{% if path_params %}
{{ indent }}    _path = f"{{ tool.path }}"
{% else %}
{{ indent }}    _path = "{{ tool.path }}"
{% endif %}
{% if query_params %}
{{ indent }}    _params: dict[str, Any] = {}
{% for p in query_params %}
{% if not p.required %}
{{ indent }}    if {{ p.name }} is not None:
{{ indent }}        _params["{{ p.name }}"] = {{ p.name }}
{% else %}
{{ indent }}    _params["{{ p.name }}"] = {{ p.name }}
{% endif %}
{% endfor %}
{% endif %}
{% if body_params %}
{{ indent }}    _body: dict[str, Any] = {}
{% for p in body_params %}
{% if not p.required %}
{{ indent }}    if {{ p.name }} is not None:
{{ indent }}        _body["{{ p.name }}"] = {{ p.name }}
{% else %}
{{ indent }}    _body["{{ p.name }}"] = {{ p.name }}
{% endif %}
{% endfor %}
{% endif %}
{{ indent }}    try:
{{ indent }}        _resp = await _client.request(
{{ indent }}            "{{ tool.method | upper }}",
{{ indent }}            _path,
{% if query_params %}
{{ indent }}            params=_params,
{% endif %}
{% if body_params %}
{{ indent }}            json_body=_body,
{% endif %}
{{ indent }}        )
{{ indent }}    except httpx.HTTPStatusError as exc:
{{ indent }}        return {
{{ indent }}            "error": True,
{{ indent }}            "source": "slskd_api",
{{ indent }}            "status": exc.response.status_code,
{{ indent }}            "message": exc.response.text[:500],
{{ indent }}            "tool": "{{ tool.name }}",
{{ indent }}        }
{{ indent }}    except httpx.RequestError as exc:
{{ indent }}        return {
{{ indent }}            "error": True,
{{ indent }}            "source": "network",
{{ indent }}            "status": 0,
{{ indent }}            "message": str(exc)[:500],
{{ indent }}            "tool": "{{ tool.name }}",
{{ indent }}        }
{% if tool.is_list and tool.response_type == "array" %}
{{ indent }}    if isinstance(_resp, list):
{{ indent }}        return _filter_response(_resp, fields=fields, filter_expr=filter)
{% elif tool.is_list and tool.response_type == "paging" %}
{{ indent }}    if isinstance(_resp, dict) and "records" in _resp:
{{ indent }}        records = _resp["records"]
{{ indent }}        filtered = _filter_response(records, fields=fields, filter_expr=filter)
{{ indent }}        filtered["totalRecords"] = _resp.get("totalRecords", 0)
{{ indent }}        filtered["page"] = _resp.get("page", 1)
{{ indent }}        filtered["pageSize"] = _resp.get("pageSize", 10)
{{ indent }}        return filtered
{% endif %}
{{ indent }}    return _resp

{% endfor %}
