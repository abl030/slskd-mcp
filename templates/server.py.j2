"""slskd MCP Server (auto-generated).

Generated for slskd API {{ slskd_version }}.
Total tools: ~{{ tool_count }}

DO NOT EDIT THIS FILE. All changes must be made in the generator or templates.
"""

from __future__ import annotations

import base64
import json
import os
from typing import Any

import httpx
from fastmcp import FastMCP

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------

SLSKD_URL = os.environ.get("SLSKD_URL", "http://localhost:5030")
SLSKD_API_KEY = os.environ.get("SLSKD_API_KEY", "")
SLSKD_MODULES = os.environ.get("SLSKD_MODULES", "")
SLSKD_READ_ONLY = os.environ.get("SLSKD_READ_ONLY", "false").lower() == "true"

# Parse enabled modules
_enabled_modules: set[str] | None = None
if SLSKD_MODULES:
    _enabled_modules = {m.strip() for m in SLSKD_MODULES.split(",") if m.strip()}

ALL_MODULES = {{ modules.keys() | list | sort }}


def _module_enabled(module: str | None) -> bool:
    """Check if a module is enabled."""
    if module is None:
        return True
    if _enabled_modules is not None:
        return module in _enabled_modules
    return True


# ---------------------------------------------------------------------------
# HTTP Client
# ---------------------------------------------------------------------------

class SlskdClient:
    """Async HTTP client for the slskd API."""

    def __init__(self) -> None:
        self._client: httpx.AsyncClient | None = None

    async def _get_client(self) -> httpx.AsyncClient:
        if self._client is None or self._client.is_closed:
            self._client = httpx.AsyncClient(
                base_url=SLSKD_URL,
                headers={"X-Api-Key": SLSKD_API_KEY},
                timeout=30.0,
                verify=False,
            )
        return self._client

    async def request(
        self,
        method: str,
        path: str,
        params: dict[str, Any] | None = None,
        json_body: dict[str, Any] | list[Any] | None = None,
    ) -> dict[str, Any] | list[Any]:
        client = await self._get_client()
        response = await client.request(
            method,
            path,
            params=params,
            json=json_body,
        )
        response.raise_for_status()
        if response.status_code == 204 or not response.content:
            return {"status": "success", "message": "No content"}
        return response.json()


_client = SlskdClient()

# ---------------------------------------------------------------------------
# Base64 encoding helper
# ---------------------------------------------------------------------------

def _b64encode(value: str) -> str:
    """Base64-encode a string for use in slskd path parameters."""
    return base64.b64encode(value.encode("utf-8")).decode("ascii")


# ---------------------------------------------------------------------------
# Response helpers
# ---------------------------------------------------------------------------

def _compact_value(v: Any) -> Any:
    """Compact a single value for list-response auto-compaction."""
    if isinstance(v, dict) and len(v) > 4:
        if "id" in v:
            return {"id": v["id"]}
        return {"_keys": len(v)}
    if isinstance(v, list) and v and isinstance(v[0], dict):
        return f"[{len(v)} items]"
    return v


def _compact_object(row: dict[str, Any]) -> dict[str, Any]:
    """Auto-compact nested objects in a single row."""
    return {k: _compact_value(v) for k, v in row.items()}


def _filter_response(
    data: list[dict[str, Any]],
    fields: str = "",
    filter_expr: str = "",
) -> dict[str, Any]:
    """Filter list response with field selection, row filtering, and auto-compaction."""
    result = data
    if filter_expr:
        for pair in filter_expr.split(","):
            pair = pair.strip()
            if "=" not in pair:
                continue
            k, v = pair.split("=", 1)
            result = [
                row for row in result
                if str(row.get(k.strip())) == v.strip()
            ]
    if fields:
        field_set = {f.strip() for f in fields.split(",")} | {"id"}
        result = [{k: v for k, v in row.items() if k in field_set} for row in result]
    else:
        result = [_compact_object(row) for row in result]
    return {"summary": f"Found {len(result)} items", "count": len(result), "data": result}


# ---------------------------------------------------------------------------
# FastMCP Server
# ---------------------------------------------------------------------------

mcp = FastMCP("slskd-mcp")

# ---------------------------------------------------------------------------
# Always-registered tools
# ---------------------------------------------------------------------------

@mcp.tool()
async def slskd_get_overview() -> dict[str, Any]:
    """Get a system overview: server state, transfer counts, search activity.

    Returns a unified summary in a single call.
    """
    import asyncio
    server, downloads, uploads, searches = await asyncio.gather(
        _client.request("GET", "/api/v0/server"),
        _client.request("GET", "/api/v0/transfers/downloads"),
        _client.request("GET", "/api/v0/transfers/uploads"),
        _client.request("GET", "/api/v0/searches"),
    )
    return {
        "server": server,
        "downloadCount": len(downloads) if isinstance(downloads, list) else 0,
        "uploadCount": len(uploads) if isinstance(uploads, list) else 0,
        "searchCount": len(searches) if isinstance(searches, list) else 0,
    }


@mcp.tool()
async def slskd_search_tools(keyword: str) -> dict[str, Any]:
    """Search for tools by keyword (e.g. 'search', 'download', 'transfer').

    Use this tool first to find the right tool before trying to call it directly.
    """
    keyword_lower = keyword.lower()
    matches = []
    for tool in mcp._tool_manager._tools.values():
        if keyword_lower in tool.name.lower() or keyword_lower in (tool.description or "").lower():
            matches.append({"name": tool.name, "description": (tool.description or "")[:120]})
    return {"summary": f"Found {len(matches)} tools matching '{keyword}'", "matches": matches}


@mcp.tool()
async def slskd_report_issue(
    tool_name: str,
    error_message: str,
    parameters_used: str = "",
    notes: str = "",
) -> str:
    """Generate a structured bug report for unexpected errors.

    Returns a ready-to-paste `gh issue create` command. Makes no HTTP calls.
    If any tool returns an unexpected error, call this to report it.
    """
    body = f"""## Bug Report

**Tool:** `{tool_name}`
**Error:** `{error_message}`
**Parameters:** `{parameters_used}`

### Notes
{notes}

### Environment
- slskd MCP Server
- Generated from OpenAPI spec
"""
    title = f"Bug: {tool_name} — {error_message[:60]}"
    cmd = f'gh issue create --repo abl030/slskd-mcp --title "{title}" --body "$(cat <<\'GHEOF\'\n{body}\nGHEOF\n)"'
    return cmd


@mcp.tool()
async def slskd_get_search_results(
    id: str,
    extension: str = "",
    minBitRate: int = 0,
    rankBy: str = "",
    limit: int = 0,
) -> dict[str, Any]:
    """Get filtered and ranked search results.

    Wraps slskd_get_searches_responses with post-filtering and source ranking.
    Use this instead of slskd_get_searches_responses when you need specific formats or bitrates.

    id: The search ID (from slskd_create_search).
    extension: Filter files by extension, e.g. "mp3", "flac". Case-insensitive.
    minBitRate: Minimum bitrate in kbps (e.g. 320). Files without bitrate info are excluded.
    rankBy: Set to "availability" to sort sources by free slots, speed, and queue depth. Values: availability.
    limit: Maximum number of sources to return. 0 returns all.

    To download a directory from results, use slskd_download_directory.
    If unexpected errors occur, call slskd_report_issue.
    """
    try:
        responses = await _client.request("GET", f"/api/v0/searches/{id}/responses")
    except httpx.HTTPStatusError as exc:
        return {
            "error": True,
            "source": "slskd_api",
            "status": exc.response.status_code,
            "message": exc.response.text[:500],
            "tool": "slskd_get_search_results",
        }
    except httpx.RequestError as exc:
        return {
            "error": True,
            "source": "network",
            "status": 0,
            "message": str(exc)[:500],
            "tool": "slskd_get_search_results",
        }

    if not isinstance(responses, list):
        responses = []

    ext_lower = extension.lower().lstrip(".") if extension else ""

    filtered_sources: list[dict[str, Any]] = []
    for resp in responses:
        files = resp.get("files", [])
        matched: list[dict[str, Any]] = []
        for f in files:
            fname = f.get("filename", "")
            if ext_lower and not fname.lower().endswith(f".{ext_lower}"):
                continue
            if minBitRate > 0:
                br = f.get("bitRate")
                if br is None or br < minBitRate:
                    continue
            matched.append(f)
        if not matched:
            continue
        source = {
            "username": resp.get("username", ""),
            "hasFreeUploadSlot": resp.get("hasFreeUploadSlot", False),
            "uploadSpeed": resp.get("uploadSpeed", 0),
            "queueLength": resp.get("queueLength", 0),
            "fileCount": len(matched),
            "files": matched,
        }
        filtered_sources.append(source)

    if rankBy == "availability":
        filtered_sources.sort(
            key=lambda s: (
                (1 if s["hasFreeUploadSlot"] else 0)
                * s["uploadSpeed"]
                / (s["queueLength"] + 1)
            ),
            reverse=True,
        )

    if limit > 0:
        filtered_sources = filtered_sources[:limit]

    total_files = sum(s["fileCount"] for s in filtered_sources)
    return {
        "summary": f"Found {total_files} files from {len(filtered_sources)} sources",
        "sources": filtered_sources,
    }


if not SLSKD_READ_ONLY:

    @mcp.tool()
    async def slskd_download_directory(
        username: str,
        directory: str,
        search_id: str,
        extension: str = "",
        minBitRate: int = 0,
        confirm: bool = False,
    ) -> dict[str, Any]:
        """Download all files from a directory found in search results.

        Resolves the file list from a previous search — no need to pass individual filenames.
        Typical workflow: slskd_create_search → slskd_get_search_results → slskd_download_directory.

        username: Soulseek username who has the files.
        directory: Directory path prefix from search results (e.g. "@@user\\Music\\Artist\\Album").
        search_id: The search ID to resolve files from.
        extension: Filter by extension, e.g. "mp3". Case-insensitive.
        minBitRate: Minimum bitrate in kbps. Files without bitrate info are excluded.
        confirm: Must be True to execute. False returns a preview of what would be downloaded.

        Requires confirm=True. Monitor progress with slskd_list_transfers_downloads.
        If unexpected errors occur, call slskd_report_issue.
        """
        try:
            responses = await _client.request("GET", f"/api/v0/searches/{search_id}/responses")
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_download_directory",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_download_directory",
            }

        if not isinstance(responses, list):
            responses = []

        # Find the response from the specified user
        user_resp = None
        for resp in responses:
            if resp.get("username", "") == username:
                user_resp = resp
                break

        if user_resp is None:
            return {
                "error": True,
                "source": "slskd_api",
                "status": 404,
                "message": f"No search results found for user '{username}' in search {search_id}",
                "tool": "slskd_download_directory",
            }

        ext_lower = extension.lower().lstrip(".") if extension else ""

        matched_files: list[dict[str, Any]] = []
        for f in user_resp.get("files", []):
            fname = f.get("filename", "")
            if not fname.startswith(directory):
                continue
            if ext_lower and not fname.lower().endswith(f".{ext_lower}"):
                continue
            if minBitRate > 0:
                br = f.get("bitRate")
                if br is None or br < minBitRate:
                    continue
            matched_files.append(f)

        if not matched_files:
            return {
                "error": True,
                "source": "slskd_api",
                "status": 404,
                "message": f"No files matching directory '{directory}' from user '{username}'",
                "tool": "slskd_download_directory",
            }

        total_size = sum(f.get("size", 0) for f in matched_files)
        filenames = [f.get("filename", "") for f in matched_files]

        if not confirm:
            return {
                "preview": f"Download {len(matched_files)} files ({total_size} bytes) from {username}",
                "confirm": "Set confirm=True to execute this download.",
                "fileCount": len(matched_files),
                "totalSize": total_size,
                "directory": directory,
                "files": filenames,
            }

        # Build the file list for the downloads API
        download_body = [{"filename": fname, "size": f.get("size", 0)} for fname, f in zip(filenames, matched_files)]

        try:
            result = await _client.request(
                "POST",
                f"/api/v0/transfers/downloads/{username}",
                json_body=download_body,
            )
        except httpx.HTTPStatusError as exc:
            return {
                "error": True,
                "source": "slskd_api",
                "status": exc.response.status_code,
                "message": exc.response.text[:500],
                "tool": "slskd_download_directory",
            }
        except httpx.RequestError as exc:
            return {
                "error": True,
                "source": "network",
                "status": 0,
                "message": str(exc)[:500],
                "tool": "slskd_download_directory",
            }

        return {
            "queued": len(matched_files),
            "totalSize": total_size,
            "directory": directory,
            "files": filenames,
        }


# ---------------------------------------------------------------------------
# Generated tools
# ---------------------------------------------------------------------------

{% for tool in tools %}
{% set indent = "" %}
{% if tool.module %}
if _module_enabled("{{ tool.module }}"):
{% set indent = "    " %}
{% endif %}
{% if tool.is_mutation %}
{{ indent }}if not SLSKD_READ_ONLY:
{% set indent = indent + "    " %}
{% endif %}

{{ indent }}@mcp.tool()
{% set required_params = tool.params | selectattr("required") | list %}
{% set optional_params = tool.params | rejectattr("required") | list %}
{% if tool.is_mutation %}
{{ indent }}async def {{ tool.name }}(
{% for p in required_params %}
{{ indent }}    {{ p.name }}: {{ p.type }},
{% endfor %}
{% if tool.is_list %}
{{ indent }}    fields: str = "",
{{ indent }}    filter: str = "",
{% endif %}
{% for p in optional_params %}
{% if p.default is none %}
{{ indent }}    {{ p.name }}: {{ p.type }} | None = None,
{% elif p.default is sameas true %}
{{ indent }}    {{ p.name }}: {{ p.type }} = True,
{% elif p.default is sameas false %}
{{ indent }}    {{ p.name }}: {{ p.type }} = False,
{% elif p.default is string %}
{{ indent }}    {{ p.name }}: {{ p.type }} = "{{ p.default }}",
{% else %}
{{ indent }}    {{ p.name }}: {{ p.type }} = {{ p.default }},
{% endif %}
{% endfor %}
{{ indent }}    confirm: bool = False,
{{ indent }}) -> dict[str, Any] | list[Any] | str:
{{ indent }}    """{{ tool.description }}

{{ indent }}    Requires confirm=True to execute. Set confirm=False to preview.
{% for p in tool.params %}
{% if p.description %}
{{ indent }}    {{ p.name }}: {{ p.description }}
{% endif %}
{% endfor %}
{% if tool.is_list %}
{{ indent }}    fields: Comma-separated field names to include. Omit for auto-compacted results.
{{ indent }}    filter: Comma-separated key=value pairs to filter rows.
{% endif %}
{{ indent }}    """
{{ indent }}    if not confirm:
{{ indent }}        return {"preview": "{{ tool.method | upper }} {{ tool.path }}", "confirm": "Set confirm=True to execute this {{ tool.method | upper }} request."}
{% else %}
{{ indent }}async def {{ tool.name }}(
{% for p in required_params %}
{{ indent }}    {{ p.name }}: {{ p.type }},
{% endfor %}
{% if tool.is_list %}
{{ indent }}    fields: str = "",
{{ indent }}    filter: str = "",
{% endif %}
{% for p in optional_params %}
{% if p.default is none %}
{{ indent }}    {{ p.name }}: {{ p.type }} | None = None,
{% elif p.default is sameas true %}
{{ indent }}    {{ p.name }}: {{ p.type }} = True,
{% elif p.default is sameas false %}
{{ indent }}    {{ p.name }}: {{ p.type }} = False,
{% elif p.default is string %}
{{ indent }}    {{ p.name }}: {{ p.type }} = "{{ p.default }}",
{% else %}
{{ indent }}    {{ p.name }}: {{ p.type }} = {{ p.default }},
{% endif %}
{% endfor %}
{{ indent }}) -> dict[str, Any] | list[Any] | str:
{{ indent }}    """{{ tool.description }}

{% for p in tool.params %}
{% if p.description %}
{{ indent }}    {{ p.name }}: {{ p.description }}
{% endif %}
{% endfor %}
{% if tool.is_list %}
{{ indent }}    fields: Comma-separated field names to include. Omit for auto-compacted results.
{{ indent }}    filter: Comma-separated key=value pairs to filter rows.
{% endif %}
{{ indent }}    """
{% endif %}
{% set path_params = tool.params | selectattr("location", "equalto", "path") | list %}
{% set query_params = tool.params | selectattr("location", "equalto", "query") | list %}
{% set body_params = tool.params | selectattr("location", "equalto", "body") | list %}
{% if tool.has_base64_params %}
{% for p in path_params %}
{% if p.name in ["base64SubdirectoryName", "base64FileName"] %}
{{ indent }}    {{ p.name }} = _b64encode({{ p.name }})
{% endif %}
{% endfor %}
{% endif %}
{% if path_params %}
{{ indent }}    _path = f"{{ tool.path }}"
{% else %}
{{ indent }}    _path = "{{ tool.path }}"
{% endif %}
{% if query_params %}
{{ indent }}    _params: dict[str, Any] = {}
{% for p in query_params %}
{% if not p.required %}
{{ indent }}    if {{ p.name }} is not None:
{{ indent }}        _params["{{ p.name }}"] = {{ p.name }}
{% else %}
{{ indent }}    _params["{{ p.name }}"] = {{ p.name }}
{% endif %}
{% endfor %}
{% endif %}
{% if body_params and not tool.is_array_body %}
{{ indent }}    _body: dict[str, Any] = {}
{% for p in body_params %}
{% if not p.required %}
{{ indent }}    if {{ p.name }} is not None:
{{ indent }}        _body["{{ p.name }}"] = {{ p.name }}
{% else %}
{{ indent }}    _body["{{ p.name }}"] = {{ p.name }}
{% endif %}
{% endfor %}
{% endif %}
{{ indent }}    try:
{{ indent }}        _resp = await _client.request(
{{ indent }}            "{{ tool.method | upper }}",
{{ indent }}            _path,
{% if query_params %}
{{ indent }}            params=_params,
{% endif %}
{% if body_params and tool.is_array_body %}
{{ indent }}            json_body=body,
{% elif body_params %}
{{ indent }}            json_body=_body,
{% endif %}
{{ indent }}        )
{{ indent }}    except httpx.HTTPStatusError as exc:
{{ indent }}        return {
{{ indent }}            "error": True,
{{ indent }}            "source": "slskd_api",
{{ indent }}            "status": exc.response.status_code,
{{ indent }}            "message": exc.response.text[:500],
{{ indent }}            "tool": "{{ tool.name }}",
{{ indent }}        }
{{ indent }}    except httpx.RequestError as exc:
{{ indent }}        return {
{{ indent }}            "error": True,
{{ indent }}            "source": "network",
{{ indent }}            "status": 0,
{{ indent }}            "message": str(exc)[:500],
{{ indent }}            "tool": "{{ tool.name }}",
{{ indent }}        }
{% if tool.is_list and tool.response_type == "array" %}
{{ indent }}    if isinstance(_resp, list):
{{ indent }}        return _filter_response(_resp, fields=fields, filter_expr=filter)
{% elif tool.is_list and tool.response_type == "paging" %}
{{ indent }}    if isinstance(_resp, dict) and "records" in _resp:
{{ indent }}        records = _resp["records"]
{{ indent }}        filtered = _filter_response(records, fields=fields, filter_expr=filter)
{{ indent }}        filtered["totalRecords"] = _resp.get("totalRecords", 0)
{{ indent }}        filtered["page"] = _resp.get("page", 1)
{{ indent }}        filtered["pageSize"] = _resp.get("pageSize", 10)
{{ indent }}        return filtered
{% endif %}
{{ indent }}    return _resp

{% endfor %}
