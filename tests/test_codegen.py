"""Tests for the codegen module and generated output quality."""

import ast
import re

from generator.loader import load_spec
from generator.context_builder import build_context
from generator.codegen import generate


class TestCodegen:
    """Test the code generation pipeline produces valid, correct output."""

    @classmethod
    def setup_class(cls):
        """Generate server.py and parse it."""
        cls.spec = load_spec()
        cls.ctx = build_context(cls.spec)
        generate(cls.ctx)

        with open("generated/server.py") as f:
            cls.code = f.read()
        cls.tree = ast.parse(cls.code)

    def test_valid_python(self):
        """Generated code must be valid Python."""
        # If setup_class parsed it, this is already true
        assert self.tree is not None

    def test_tool_function_count(self):
        """Should have 96 async def slskd_* functions (93 generated + 3 always-registered)."""
        funcs = re.findall(r"async def (slskd_\w+)\(", self.code)
        assert len(funcs) == 96

    def test_module_gating_present(self):
        """Module gating blocks should be present."""
        assert 'if _module_enabled("searches")' in self.code
        assert 'if _module_enabled("transfers")' in self.code
        assert 'if _module_enabled("users")' in self.code

    def test_readonly_gating_present(self):
        """Read-only gating should wrap mutation tools."""
        assert "if not SLSKD_READ_ONLY:" in self.code

    def test_confirmation_gates(self):
        """Mutation tools should require confirm=True."""
        # Count confirm parameters
        confirm_count = len(re.findall(r"confirm: bool = False", self.code))
        # Count mutations in context
        mutation_count = sum(1 for t in self.ctx["tools"] if t["is_mutation"])
        assert confirm_count == mutation_count

    def test_base64_encoding(self):
        """Base64 params should be auto-encoded."""
        assert "_b64encode(base64SubdirectoryName)" in self.code
        assert "_b64encode(base64FileName)" in self.code

    def test_filter_response_used(self):
        """List tools should use _filter_response."""
        list_tools = [t for t in self.ctx["tools"] if t["is_list"]]
        assert len(list_tools) > 0
        assert "_filter_response(" in self.code

    def test_array_body_direct(self):
        """Array body tools should pass body directly, not wrapped in dict."""
        # slskd_create_transfers_downloads should have json_body=body
        # Find the function and check it does NOT have _body["body"] = body
        dl_match = re.search(
            r"async def slskd_create_transfers_downloads\(.*?\n(?:.*?\n)*?.*?return _resp",
            self.code,
        )
        assert dl_match, "slskd_create_transfers_downloads not found"
        dl_code = dl_match.group()
        assert "json_body=body" in dl_code
        assert '_body["body"]' not in dl_code

    def test_always_registered_tools(self):
        """Overview, search_tools, and report_issue should always be registered."""
        assert "async def slskd_get_overview(" in self.code
        assert "async def slskd_search_tools(" in self.code
        assert "async def slskd_report_issue(" in self.code

    def test_error_handling_pattern(self):
        """Every generated tool should have HTTP + network error handling."""
        for tool in self.ctx["tools"]:
            assert f'"tool": "{tool["name"]}"' in self.code, (
                f"{tool['name']} missing error tool reference"
            )

    def test_no_hand_edit_warning(self):
        """Generated file should have DO NOT EDIT header."""
        assert "DO NOT EDIT THIS FILE" in self.code

    def test_slskd_client_class(self):
        """SlskdClient class should be present."""
        assert "class SlskdClient:" in self.code

    def test_x_api_key_header(self):
        """X-Api-Key authentication should be configured."""
        assert '"X-Api-Key"' in self.code

    def test_workflow_hints_in_generated_code(self):
        """Key tools should have workflow hints in their generated docstrings."""
        checks = {
            "slskd_create_search": "slskd_get_searches_responses",
            "slskd_get_users_browse": "slskd_create_transfers_downloads",
            "slskd_create_conversations": "slskd_get_conversations_messages",
        }
        for func_name, hint_text in checks.items():
            start = self.code.index(f"async def {func_name}(")
            next_func = self.code.find("\nasync def ", start + 1)
            if next_func == -1:
                next_func = self.code.find("\n    async def ", start + 1)
            chunk = self.code[start:next_func] if next_func != -1 else self.code[start:]
            assert hint_text in chunk, f"{func_name} missing hint for {hint_text}"

    def test_response_enums_in_generated_code(self):
        """Response enum values should appear in generated tool docstrings."""
        checks = {
            "slskd_list_transfers_downloads": "Succeeded",
            "slskd_list_server": "Disconnected",
            "slskd_list_events": "DownloadFileComplete",
            "slskd_get_users_status": "Offline",
        }
        for func_name, enum_value in checks.items():
            start = self.code.index(f"async def {func_name}(")
            next_func = self.code.find("\nasync def ", start + 1)
            if next_func == -1:
                next_func = self.code.find("\n    async def ", start + 1)
            chunk = self.code[start:next_func] if next_func != -1 else self.code[start:]
            assert enum_value in chunk, f"{func_name} missing enum value {enum_value}"

    def test_clean_tool_names(self):
        """No generated function should have ugly dedup suffixes."""
        funcs = re.findall(r"async def (slskd_\w+)\(", self.code)
        for name in funcs:
            assert not name.endswith("_get"), f"{name} has _get dedup suffix"
            assert not name.endswith("_put"), f"{name} has _put dedup suffix"
